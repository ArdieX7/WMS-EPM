version: '3.8'

# Docker Compose per Produzione WMS
# Versione ottimizzata per deployment su VPS

services:
  web:
    build: 
      context: .
      dockerfile: Dockerfile
    container_name: wms_web
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://wms_user:${DB_PASSWORD}@db:5432/wms_db
      - ENVIRONMENT=production
      - DEBUG=False
      - LOG_LEVEL=INFO
    env_file:
      - .env
    depends_on:
      db:
        condition: service_healthy
    volumes:
      - ./wms_app/static:/app/wms_app/static:ro
      - ./media:/app/media
      - ./logs:/app/logs
      - /etc/localtime:/etc/localtime:ro  # Sync timezone
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    deploy:
      resources:
        limits:
          cpus: '1.5'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 256M
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    networks:
      - wms_network

  db:
    image: postgres:15-alpine
    container_name: wms_db
    environment:
      - POSTGRES_DB=wms_db
      - POSTGRES_USER=wms_user
      - POSTGRES_PASSWORD=${DB_PASSWORD}
      - POSTGRES_INITDB_ARGS=--encoding=UTF-8 --lc-collate=C --lc-ctype=C
      - PGDATA=/var/lib/postgresql/data/pgdata
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./backups/db:/backups  # For manual backups
      - /etc/localtime:/etc/localtime:ro
    ports:
      - "127.0.0.1:5432:5432"  # Bind only to localhost for security
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U wms_user -d wms_db"]
      interval: 30s
      timeout: 5s
      retries: 5
      start_period: 30s
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 128M
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    networks:
      - wms_network
    # PostgreSQL tuning
    command: >
      postgres
      -c max_connections=100
      -c shared_buffers=256MB
      -c effective_cache_size=1GB
      -c maintenance_work_mem=64MB
      -c checkpoint_completion_target=0.9
      -c wal_buffers=16MB
      -c default_statistics_target=100
      -c random_page_cost=1.1
      -c effective_io_concurrency=200
      -c work_mem=4MB
      -c min_wal_size=1GB
      -c max_wal_size=4GB
      -c max_worker_processes=8
      -c max_parallel_workers_per_gather=4
      -c max_parallel_workers=8
      -c max_parallel_maintenance_workers=4
      -c logging_collector=on
      -c log_filename='postgresql-%Y%m%d_%H%M%S.log'
      -c log_truncate_on_rotation=on
      -c log_rotation_age=1d
      -c log_rotation_size=100MB

  # Redis per caching (opzionale ma consigliato)
  redis:
    image: redis:7-alpine
    container_name: wms_redis
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD}
    volumes:
      - redis_data:/data
      - /etc/localtime:/etc/localtime:ro
    ports:
      - "127.0.0.1:6379:6379"  # Bind only to localhost
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "--raw", "incr", "ping"]
      interval: 30s
      timeout: 3s
      retries: 5
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 256M
        reservations:
          cpus: '0.1'
          memory: 64M
    logging:
      driver: "json-file"
      options:
        max-size: "5m"
        max-file: "2"
    networks:
      - wms_network

  # Nginx come reverse proxy (opzionale, se non usi nginx di sistema)
  # nginx:
  #   image: nginx:alpine
  #   container_name: wms_nginx
  #   ports:
  #     - "80:80"
  #     - "443:443"
  #   volumes:
  #     - ./nginx-production.conf:/etc/nginx/conf.d/default.conf:ro
  #     - ./ssl_certs:/etc/nginx/ssl:ro
  #     - ./wms_app/static:/var/www/static:ro
  #     - /etc/localtime:/etc/localtime:ro
  #   depends_on:
  #     - web
  #   restart: unless-stopped
  #   healthcheck:
  #     test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost/health"]
  #     interval: 30s
  #     timeout: 3s
  #     retries: 3
  #   deploy:
  #     resources:
  #       limits:
  #         cpus: '0.5'
  #         memory: 128M
  #       reservations:
  #         cpus: '0.1'
  #         memory: 32M
  #   logging:
  #     driver: "json-file"
  #     options:
  #       max-size: "10m"
  #       max-file: "3"
  #   networks:
  #     - wms_network

  # Watchtower per auto-updates (opzionale)
  watchtower:
    image: containrrr/watchtower
    container_name: wms_watchtower
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - /etc/localtime:/etc/localtime:ro
    environment:
      - WATCHTOWER_CLEANUP=true
      - WATCHTOWER_REMOVE_VOLUMES=true
      - WATCHTOWER_INCLUDE_STOPPED=true
      - WATCHTOWER_POLL_INTERVAL=86400  # 24 hours
      - WATCHTOWER_NOTIFICATIONS=shoutrrr
      - WATCHTOWER_NOTIFICATION_URL=${WATCHTOWER_WEBHOOK_URL}
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: '0.1'
          memory: 64M
        reservations:
          cpus: '0.01'
          memory: 16M
    logging:
      driver: "json-file"
      options:
        max-size: "5m"
        max-file: "1"
    networks:
      - wms_network

  # Monitoring con Portainer (opzionale)
  portainer:
    image: portainer/portainer-ce:latest
    container_name: wms_portainer
    ports:
      - "127.0.0.1:9000:9000"  # Bind only to localhost
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - portainer_data:/data
      - /etc/localtime:/etc/localtime:ro
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: '0.2'
          memory: 128M
        reservations:
          cpus: '0.05'
          memory: 32M
    logging:
      driver: "json-file"
      options:
        max-size: "5m"
        max-file: "2"
    networks:
      - wms_network

volumes:
  postgres_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /opt/projects/WMS_EPM/data/postgres
  redis_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /opt/projects/WMS_EPM/data/redis
  portainer_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /opt/projects/WMS_EPM/data/portainer

networks:
  wms_network:
    driver: bridge
    ipam:
      driver: default
      config:
        - subnet: 172.20.0.0/16
    driver_opts:
      com.docker.network.bridge.name: wms_bridge